--
--  Generated by RecordFlux 0.5.0-pre on 2021-07-25
--
--  Copyright (C) 2018-2021 Componolit GmbH
--
--  This file is distributed under the terms of the GNU Affero General Public License version 3.
--

pragma Style_Checks ("N3aAbcdefhiIklnOprStux");
pragma Warnings (Off, "redundant conversion");
with Ada.Text_IO;
with RFLX.PIN_FSM;
use type RFLX.PIN_FSM.PIN;
use type RFLX.PIN_FSM.Retries;
use type RFLX.PIN_FSM.Kind;

package body RFLX.PIN_FSM.Authentication with
  SPARK_Mode
is

   procedure Initialize (State : out Session_State) with
     Pre =>
       Initialized,
     Post =>
       Initialized
   is
   begin
      declare
         procedure PIN_FSM_Config_Write is new PIN_FSM.Config.Write (Config_Channel_Read);
      begin
         PIN_FSM_Config_Write (Config_Ctx);
      end;
      PIN_FSM.Config.Verify_Message (Config_Ctx);
      if PIN_FSM.Config.Structural_Valid_Message (Config_Ctx) = False then
         State := S_Error;
      else
         State := S_Setup;
      end if;
   end Initialize;

   procedure Setup (State : out Session_State) with
     Pre =>
       Initialized,
     Post =>
       Initialized
   is
   begin
      if PIN_FSM.Config.Valid (Config_Ctx, PIN_FSM.Config.F_PIN) then
         PIN := PIN_FSM.Config.Get_PIN (Config_Ctx);
      else
         Ada.Text_IO.Put_Line ("Error: access to invalid field ""PIN"" of ""Config_Ctx""");
         State := S_Error;
         return;
      end if;
      if PIN_FSM.Config.Valid (Config_Ctx, PIN_FSM.Config.F_Max_Retries) then
         Max_Retries := PIN_FSM.Config.Get_Max_Retries (Config_Ctx);
      else
         Ada.Text_IO.Put_Line ("Error: access to invalid field ""Max_Retries"" of ""Config_Ctx""");
         State := S_Error;
         return;
      end if;
      State := S_Locked;
   end Setup;

   procedure Locked (State : out Session_State) with
     Pre =>
       Initialized,
     Post =>
       Initialized
   is
   begin
      declare
         procedure PIN_FSM_Request_Write is new PIN_FSM.Request.Write (User_Channel_Read);
      begin
         PIN_FSM_Request_Write (Request_Ctx);
      end;
      PIN_FSM.Request.Verify_Message (Request_Ctx);
      Retries := Retries + 1;
      if PIN_FSM.Request.Structural_Valid_Message (Request_Ctx) = False then
         State := S_Error;
      elsif Retries > Max_Retries then
         State := S_Disabled;
      elsif
        PIN_FSM.Request.Get_Kind (Request_Ctx) = Auth
        and then PIN_FSM.Request.Get_PIN (Request_Ctx) = PIN
      then
         State := S_Authenticated;
      elsif
        (PIN_FSM.Request.Get_Kind (Request_Ctx) = Auth
         and then PIN_FSM.Request.Get_PIN (Request_Ctx) /= PIN)
        or else PIN_FSM.Request.Get_Kind (Request_Ctx) = Deauth
      then
         State := S_Locked;
      else
         State := S_Error;
      end if;
   end Locked;

   procedure Disabled (State : out Session_State) with
     Pre =>
       Initialized,
     Post =>
       Initialized
   is
   begin
      State := S_Disabled;
   end Disabled;

   procedure Authenticated (State : out Session_State) with
     Pre =>
       Initialized,
     Post =>
       Initialized
   is
   begin
      Retries := 0;
      declare
         procedure PIN_FSM_Request_Write is new PIN_FSM.Request.Write (User_Channel_Read);
      begin
         PIN_FSM_Request_Write (Request_Ctx);
      end;
      PIN_FSM.Request.Verify_Message (Request_Ctx);
      if PIN_FSM.Request.Structural_Valid_Message (Request_Ctx) = False then
         State := S_Error;
      elsif
        PIN_FSM.Request.Get_Kind (Request_Ctx) = Auth
        and then PIN = PIN_FSM.Request.Get_PIN (Request_Ctx)
      then
         State := S_Authenticated;
      elsif
        (PIN_FSM.Request.Get_Kind (Request_Ctx) = Auth
         and then PIN /= PIN_FSM.Request.Get_PIN (Request_Ctx))
        or else PIN_FSM.Request.Get_Kind (Request_Ctx) = Deauth
      then
         State := S_Locked;
      elsif PIN_FSM.Request.Get_Kind (Request_Ctx) = Forward then
         State := S_Forwarding;
      elsif PIN_FSM.Request.Get_Kind (Request_Ctx) = Change then
         State := S_Update;
      else
         State := S_Error;
      end if;
   end Authenticated;

   procedure Update (State : out Session_State) with
     Pre =>
       Initialized,
     Post =>
       Initialized
   is
   begin
      if PIN_FSM.Request.Valid (Request_Ctx, PIN_FSM.Request.F_PIN) then
         PIN := PIN_FSM.Request.Get_PIN (Request_Ctx);
      else
         Ada.Text_IO.Put_Line ("Error: access to invalid field ""PIN"" of ""Request_Ctx""");
         State := S_Error;
         return;
      end if;
      State := S_Authenticated;
   end Update;

   procedure Forwarding (State : out Session_State) with
     Pre =>
       Initialized,
     Post =>
       Initialized
   is
   begin
      if PIN_FSM.Request.Structural_Valid_Message (Request_Ctx) then
         declare
            procedure PIN_FSM_Request_Read is new PIN_FSM.Request.Read (Upstream_Channel_Write);
         begin
            PIN_FSM_Request_Read (Request_Ctx);
         end;
      else
         Ada.Text_IO.Put_Line ("Error: invalid message ""Request_Ctx""");
         State := S_Error;
         return;
      end if;
      State := S_Authenticated;
   end Forwarding;

   procedure Initialize is
      Request_Buffer : RFLX_Types.Bytes_Ptr;
      Config_Buffer : RFLX_Types.Bytes_Ptr;
   begin
      if PIN_FSM.Request.Has_Buffer (Request_Ctx) then
         pragma Warnings (Off, "unused assignment to ""Request_Ctx""");
         pragma Warnings (Off, """Request_Ctx"" is set by ""Take_Buffer"" but not used after the call");
         PIN_FSM.Request.Take_Buffer (Request_Ctx, Request_Buffer);
         pragma Warnings (On, """Request_Ctx"" is set by ""Take_Buffer"" but not used after the call");
         pragma Warnings (On, "unused assignment to ""Request_Ctx""");
         RFLX_Types.Free (Request_Buffer);
      end if;
      Request_Buffer := new RFLX_Types.Bytes'(RFLX_Types.Index'First .. RFLX_Types.Index'First + 4095 => RFLX_Types.Byte'First);
      PIN_FSM.Request.Initialize (Request_Ctx, Request_Buffer);
      if PIN_FSM.Config.Has_Buffer (Config_Ctx) then
         pragma Warnings (Off, "unused assignment to ""Config_Ctx""");
         pragma Warnings (Off, """Config_Ctx"" is set by ""Take_Buffer"" but not used after the call");
         PIN_FSM.Config.Take_Buffer (Config_Ctx, Config_Buffer);
         pragma Warnings (On, """Config_Ctx"" is set by ""Take_Buffer"" but not used after the call");
         pragma Warnings (On, "unused assignment to ""Config_Ctx""");
         RFLX_Types.Free (Config_Buffer);
      end if;
      Config_Buffer := new RFLX_Types.Bytes'(RFLX_Types.Index'First .. RFLX_Types.Index'First + 4095 => RFLX_Types.Byte'First);
      PIN_FSM.Config.Initialize (Config_Ctx, Config_Buffer);
      State := S_Initialize;
   end Initialize;

   procedure Finalize is
      Request_Buffer : RFLX_Types.Bytes_Ptr;
      Config_Buffer : RFLX_Types.Bytes_Ptr;
   begin
      pragma Warnings (Off, "unused assignment to ""Request_Ctx""");
      pragma Warnings (Off, """Request_Ctx"" is set by ""Take_Buffer"" but not used after the call");
      PIN_FSM.Request.Take_Buffer (Request_Ctx, Request_Buffer);
      pragma Warnings (On, """Request_Ctx"" is set by ""Take_Buffer"" but not used after the call");
      pragma Warnings (On, "unused assignment to ""Request_Ctx""");
      RFLX_Types.Free (Request_Buffer);
      pragma Warnings (Off, "unused assignment to ""Config_Ctx""");
      pragma Warnings (Off, """Config_Ctx"" is set by ""Take_Buffer"" but not used after the call");
      PIN_FSM.Config.Take_Buffer (Config_Ctx, Config_Buffer);
      pragma Warnings (On, """Config_Ctx"" is set by ""Take_Buffer"" but not used after the call");
      pragma Warnings (On, "unused assignment to ""Config_Ctx""");
      RFLX_Types.Free (Config_Buffer);
      State := S_Error;
   end Finalize;

   procedure Tick is
   begin
      case State is
         when S_Initialize =>
            Ada.Text_IO.Put_Line ("State: Initialize");
            Initialize (State);
         when S_Setup =>
            Ada.Text_IO.Put_Line ("State: Setup");
            Setup (State);
         when S_Locked =>
            Ada.Text_IO.Put_Line ("State: Locked");
            Locked (State);
         when S_Disabled =>
            Ada.Text_IO.Put_Line ("State: Disabled");
            Disabled (State);
         when S_Authenticated =>
            Ada.Text_IO.Put_Line ("State: Authenticated");
            Authenticated (State);
         when S_Update =>
            Ada.Text_IO.Put_Line ("State: Update");
            Update (State);
         when S_Forwarding =>
            Ada.Text_IO.Put_Line ("State: Forwarding");
            Forwarding (State);
         when S_Error =>
            Ada.Text_IO.Put_Line ("State: Error");
            null;
      end case;
   end Tick;

   procedure Run is
   begin
      Initialize;
      while Active loop
         pragma Loop_Invariant (Initialized);
         Tick;
      end loop;
      Finalize;
   end Run;

end RFLX.PIN_FSM.Authentication;
